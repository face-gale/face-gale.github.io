(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{593:function(e,n,t){"use strict";t.r(n);var a=t(42),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"kubernetes-通过资源配置运行容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-通过资源配置运行容器"}},[e._v("#")]),e._v(" Kubernetes 通过资源配置运行容器")]),e._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("p",[e._v("我们知道通过 run 命令启动容器非常麻烦，Docker 提供了 Compose 为我们解决了这个问题。那 Kubernetes 是如何解决这个问题的呢？其实很简单，使用 kubectl create 命令就可以做到和 Compose 一样的效果了，该命令可以通过配置文件快速创建一个集群资源对象。")]),e._v(" "),t("h2",{attrs:{id:"创建-yaml-配置文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建-yaml-配置文件"}},[e._v("#")]),e._v(" 创建 YAML 配置文件")]),e._v(" "),t("h3",{attrs:{id:"部署-deployment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#部署-deployment"}},[e._v("#")]),e._v(" 部署 Deployment")]),e._v(" "),t("p",[e._v("创建一个名为 "),t("code",[e._v("nginx.yml")]),e._v(" 的配置文件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# API 版本号\napiVersion: apps/v1\n# 类型，如：Pod/ReplicationController/Deployment/Service/Ingress\nkind: Deployment\n# 元数据\nmetadata:\n  # Kind 的名称\n  name: nginx-app\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  # 部署的实例数量\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        # 容器标签的名字，发布 Service 时，selector 需要和这里对应\n        app: nginx\n    spec:\n      # 配置容器，数组类型，说明可以配置多个容器\n      containers:\n      # 容器名称\n      - name: nginx\n        # 容器镜像\n        image: nginx:1.17\n        # 只有镜像不存在时，才会进行镜像拉取\n        imagePullPolicy: IfNotPresent\n        # 暴露端口\n        ports:\n        # Pod 端口\n        - containerPort: 80\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 部署\nkubectl create -f nginx.yml\n# 删除\nkubectl delete -f nginx.yml\n")])])]),t("h3",{attrs:{id:"发布-service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布-service"}},[e._v("#")]),e._v(" 发布 Service")]),e._v(" "),t("p",[e._v("创建一个名为 "),t("code",[e._v("nginx-service.yml")]),e._v(" 的配置文件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# API 版本号\napiVersion: v1\n# 类型，如：Pod/ReplicationController/Deployment/Service/Ingress\nkind: Service\n# 元数据\nmetadata:\n  # Kind 的名称\n  name: nginx-http\nspec:\n  # 暴露端口\n  ports:\n    ## Service 暴露的端口\n    - port: 80\n      ## Pod 上的端口，这里是将 Service 暴露的端口转发到 Pod 端口上\n      targetPort: 80\n  # 类型\n  type: LoadBalancer\n  # 标签选择器\n  selector:\n    # 需要和上面部署的 Deployment 标签名对应\n    app: nginx\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 部署\nkubectl create -f nginx-service.yml\n# 删除\nkubectl delete -f nginx-service.yml\n")])])]),t("blockquote",[t("p",[e._v("但是其实也可以将上面两种配置放在一个文件一起执行，中间用"),t("code",[e._v("---")]),e._v("分割。")])]),e._v(" "),t("h2",{attrs:{id:"镜像拉取策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#镜像拉取策略"}},[e._v("#")]),e._v(" 镜像拉取策略")]),e._v(" "),t("p",[e._v("支持三种 ImagePullPolicy")]),e._v(" "),t("ul",[t("li",[e._v("Always： 不管镜像是否存在都会进行一次拉取")]),e._v(" "),t("li",[e._v("Never： 不管镜像是否存在都不会进行拉取")]),e._v(" "),t("li",[e._v("IfNotPresent： 只有镜像不存在时，才会进行镜像拉取")])]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),t("ul",[t("li",[e._v("默认为 IfNotPresent，但 :latest 标签的镜像默认为 Always")]),e._v(" "),t("li",[e._v("拉取镜像时 Docker 会进行校验，如果镜像中的 MD5 码没有变，则不会拉取镜像数据")]),e._v(" "),t("li",[e._v("生产环境中应该尽量避免使用 :latest 标签，而开发环境中可以借助 :latest 标签自动拉取最新的镜像")])])]),e._v(" "),t("h2",{attrs:{id:"验证是否生效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验证是否生效"}},[e._v("#")]),e._v(" 验证是否生效")]),e._v(" "),t("h3",{attrs:{id:"查看-pod-列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-pod-列表"}},[e._v("#")]),e._v(" 查看 Pod 列表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("kubectl get pods\n# 输出如下\nNAME                         READY   STATUS    RESTARTS   AGE\nnginx-app-64bb598779-2pplx   1/1     Running   0          25m\nnginx-app-64bb598779-824lc   1/1     Running   0          25m\n")])])]),t("h3",{attrs:{id:"查看-deployment-列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-deployment-列表"}},[e._v("#")]),e._v(" 查看 Deployment 列表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("kubectl get deployment\n# 输出如下\nNAME        READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-app   2/2     2            2           25m\n")])])]),t("h3",{attrs:{id:"查看-service-列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-service-列表"}},[e._v("#")]),e._v(" 查看 Service 列表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("kubectl get service\n# 输出如下\nNAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nkubernetes   ClusterIP      10.96.0.1       <none>        443/TCP        20h\nnginx-http   LoadBalancer   10.102.177.35   <pending>     80:32435/TCP   25s\n")])])]),t("h3",{attrs:{id:"查看-service-详情"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-service-详情"}},[e._v("#")]),e._v(" 查看 Service 详情")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("kubectl describe service nginx\n# 输出如下\nName:                     nginx-http\nNamespace:                default\nLabels:                   <none>\nAnnotations:              <none>\nSelector:                 app=nginx\nType:                     LoadBalancer\nIP:                       10.102.177.35\nPort:                     <unset>  80/TCP\nTargetPort:               80/TCP\nNodePort:                 <unset>  32435/TCP\nEndpoints:                10.244.140.68:80,10.244.141.199:80\nSession Affinity:         None\nExternal Traffic Policy:  Cluster\nEvents:                   <none>\n")])])]),t("h3",{attrs:{id:"通过浏览器访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过浏览器访问"}},[e._v("#")]),e._v(" 通过浏览器访问")]),e._v(" "),t("p",[e._v("通过浏览器访问 "),t("code",[e._v("http://192.168.141.120:31631/")]),e._v(" ，出现 Nginx 欢迎页即表示成功")]),e._v(" "),t("h2",{attrs:{id:"集成环境部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集成环境部署"}},[e._v("#")]),e._v(" 集成环境部署")]),e._v(" "),t("p",[e._v("也可以不区分配置文件，一次性部署 Deployment 和 Service，创建一个名为 nginx.yml 的配置文件，配置内容如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-app\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx\n        ports:\n        - containerPort: 80\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-http\nspec:\n  ports:\n    - port: 80\n      targetPort: 80\n      # 可以指定 NodePort 端口，默认范围是：30000-32767\n      # nodePort: 30080\n  type: LoadBalancer\n  selector:\n    app: nginx\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 部署\nkubectl create -f nginx.yml\n# 删除\nkubectl delete -f nginx.yml\n")])])]),t("h2",{attrs:{id:"附：扩展阅读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#附：扩展阅读"}},[e._v("#")]),e._v(" 附：扩展阅读")]),e._v(" "),t("h3",{attrs:{id:"修改默认的端口范围"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改默认的端口范围"}},[e._v("#")]),e._v(" 修改默认的端口范围")]),e._v(" "),t("p",[e._v("Kubernetes 服务的 NodePort 默认端口范围是 30000-32767，在某些场合下，这个限制不太适用，我们可以自定义它的端口范围，操作步骤如下：")]),e._v(" "),t("p",[e._v("编辑"),t("code",[e._v("vi /etc/kubernetes/manifests/kube-apiserver.yaml")]),e._v(" 配置文件，增加配置 "),t("code",[e._v("--service-node-port-range=2-65535")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("apiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    component: kube-apiserver\n    tier: control-plane\n  name: kube-apiserver\n  namespace: kube-system\nspec:\n  containers:\n  - command:\n    - kube-apiserver\n    # 在这里增加配置即可\n    - --service-node-port-range=2-65535\n    - --advertise-address=192.168.141.150\n    - --allow-privileged=true\n    - --authorization-mode=Node,RBAC\n    - --client-ca-file=/etc/kubernetes/pki/ca.crt\n    - --enable-admission-plugins=NodeRestriction\n    - --enable-bootstrap-token-auth=true\n    - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt\n    - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt\n// 以下配置省略...\n")])])]),t("p",[e._v("使用 docker ps 命令找到"),t("code",[e._v("kube-apiserver")]),e._v(" 容器，再使用 "),t("code",[e._v("docker restart <ApiServer 容器 ID>")]),e._v(" 即可生效。")])])}),[],!1,null,null,null);n.default=s.exports}}]);
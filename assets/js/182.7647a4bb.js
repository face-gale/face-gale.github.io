(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{529:function(a,s,e){"use strict";e.r(s);var n=e(42),t=Object(n.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"双亲委派模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),e("h2",{attrs:{id:"类加载器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),e("h3",{attrs:{id:"加载类的开放性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加载类的开放性"}},[a._v("#")]),a._v(" 加载类的开放性")]),a._v(" "),e("p",[a._v("类加载器（ClassLoader）是 Java 语言的一项创新，也是 Java 流行的一个重要原因。在类加载的第一阶段“加载”过程中，需要通过一个类的全限定名来获取定义此类的二进制字节流，完成这个动作的代码块就是 类加载器。这一动作是放在 Java 虚拟机外部去实现的，以便让应用程序自己决定如何获取所需的类。")]),a._v(" "),e("p",[a._v("虚拟机规范并没有指明二进制字节流要从一个 Class 文件获取，或者说根本没有指明从哪里获取、怎样获取。这种开放使得 Java 在很多领域得到充分运用，例如：")]),a._v(" "),e("ul",[e("li",[a._v("从 ZIP 包中读取，这很常见，成为 JAR，EAR，WAR 格式的基础")]),a._v(" "),e("li",[a._v("从网络中获取，最典型的应用就是 Applet")]),a._v(" "),e("li",[a._v("运行时计算生成，最典型的是动态代理技术，在 "),e("code",[a._v("java.lang.reflect.Proxy")]),a._v(" 中，就是用了 "),e("code",[a._v("ProxyGenerator.generateProxyClass")]),a._v(" 来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流")]),a._v(" "),e("li",[a._v("有其他文件生成，最典型的 JSP 应用，由 JSP 文件生成对应的 Class 类")])]),a._v(" "),e("h3",{attrs:{id:"类加载器与类的唯一性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类加载器与类的唯一性"}},[a._v("#")]),a._v(" 类加载器与类的唯一性")]),a._v(" "),e("p",[a._v("类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立其在 Java 虚拟机中的 唯一性。通俗的说，JVM 中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要类加载器不同，那么这两个类必定是不相等的。")]),a._v(" "),e("p",[a._v("这里的“相等”，包括代表类的 Class 对象的 "),e("code",[a._v("equals()")]),a._v(" 方法、"),e("code",[a._v("isAssignableFrom()")]),a._v(" 方法、"),e("code",[a._v("isInstance()")]),a._v(" 方法的返回结果，也包括使用 "),e("code",[a._v("instanceof")]),a._v(" 关键字做对象所属关系判定等情况。")]),a._v(" "),e("p",[a._v("下代码说明了不同的类加载器对 "),e("code",[a._v("instanceof")]),a._v(" 关键字运算的结果的影响。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('package com.jvm.classloading;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * 类加载器在类相等判断中的影响\n * \n * instanceof关键字\n * \n */\n\npublic class ClassLoaderTest {\n    public static void main(String[] args) throws Exception {\n        // 自定义类加载器\n        ClassLoader myLoader = new ClassLoader() {\n            @Override\n            public Class<?> loadClass(String name) throws ClassNotFoundException {\n                try {\n                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";\n                    InputStream is = getClass().getResourceAsStream(fileName);\n                    if (is == null) {\n                        return super.loadClass(fileName);\n                    }\n                    byte[] b = new byte[is.available()];\n                    is.read(b);\n                    return defineClass(name, b, 0, b.length);   \n                } catch (IOException e) {\n                    throw new ClassNotFoundException();\n                }\n            }\n        };\n\n        // 使用 ClassLoaderTest 的类加载器加载本类\n        Object obj1 = ClassLoaderTest.class.getClassLoader().loadClass("com.jvm.classloading.ClassLoaderTest").newInstance();\n        System.out.println(obj1.getClass());\n        System.out.println(obj1 instanceof com.jvm.classloading.ClassLoaderTest);\n\n        // 使用自定义类加载器加载本类\n        Object obj2 = myLoader.loadClass("com.jvm.classloading.ClassLoaderTest").newInstance();\n        System.out.println(obj2.getClass());\n        System.out.println(obj2 instanceof com.jvm.classloading.ClassLoaderTest);\n    }\n}\n')])])]),e("p",[a._v("输出结果：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class com.jvm.classloading.ClassLoaderTest\ntrue\nclass com.jvm.classloading.ClassLoaderTest\nfalse\n")])])])])}),[],!1,null,null,null);s.default=t.exports}}]);